#include <cuda_runtime.h>

__global__ void convolution_2d_kernel(const float *input, const float *kernel, float *output,
                                int input_rows, int input_cols, int kernel_rows, int kernel_cols) {


    int row = blockDim.y * blockIdx.y + threadIdx.y;
    int col = blockDim.x * blockIdx.x + threadIdx.x;

    int out_rows = input_rows - kernel_rows + 1;
    int out_cols = input_cols - kernel_cols + 1;
    
    if (row < out_rows && col < out_cols){
        float out_val = 0.0f;
        
        for (int fRow = 0; fRow < kernel_rows; ++fRow) 
            for (int fCol = 0; fCol < kernel_cols; ++fCol)
                out_val += input[(row + fRow) * input_cols + col + fCol] * kernel[fRow * kernel_cols + fCol];
        output[row * out_cols + col ] = out_val;
    }
}

// input, kernel, output are device pointers
extern "C" void solve(const float* input, const float* kernel, float* output,
           int input_rows, int input_cols, int kernel_rows, int kernel_cols) {
            
    int output_rows = input_rows - kernel_rows + 1;
    int output_cols = input_cols - kernel_cols + 1;

    dim3 threadsPerBlock(32, 32);
    dim3 blocksPerGrid((output_cols + threadsPerBlock.x - 1) / threadsPerBlock.x,
                        (output_rows + threadsPerBlock.y - 1) / threadsPerBlock.y);

    convolution_2d_kernel<<<blocksPerGrid, threadsPerBlock>>>(input, kernel, output, input_rows, input_cols, kernel_rows, kernel_cols);
    cudaDeviceSynchronize();
}
